[Chapter8] 클래스
======================
# 8.1. 클래스 메서드
타입스크립트는 독립함수를 이해하는 것과 동일한 방식으로 메서드를 이해합니다. 매개변수 타입이나 기본값을 지정하지 않으면 any 타입을 기본으로 갖습니다. 메서드를 호출하려면 허용 가능한 수의 인수가 필요하고, 재귀 함수가 아니라면 대부분 반환 타입을 유추 가능합니다.
# 8.2. 클래스 속성
클래스의 속성을 읽거나 쓰려면 클래스에 명시적으로 선언해야 합니다. 클래스 속성은 인터페이스와 동일한 구문을 사용해 선언합니다. 클래스 속성 이름 뒤에는 선택적으로 타입 애너테이션이 붙습니다.
### 8.2.1 함수 속성
자바스크립트에는 클래스의 멤버를 호출 가능한 함수로 선언하는 두가지 구문이 있습니다. myFuction(){}과 같이 멤버 이름 뒤에 괄호를 붙이는 메서드 접근 방식은 클래스 프로토 타입에 할당되므로 모든 클래스 인스턴스는 동일한 함수 정의를 사용합니다. 항상 클래스 인스턴스에서 화살표 함수에서는 this 스코프를 사용하면 클래스 인스턴스당 새로운 함수를 생성하는 시간과 메모리 비용측면에서 좋습니다.
### 8.2.2 초기화 검사
엄격한 컴파일러 설정이 활성화되면 타입스크립트는 undefined 타입으로 선언된 각 속성이 생성자에서 할당되었는지 확인합니다. 
 * 확실하게 할당된 속성 :엄격한 초기화 검사가 유용한 경우가 대부분이지만 클래스 생성자 다음에 클래스 속성을 의도적으로 할당하지 않는 경우가 있을수 있습니다.
### 8.2.3 선택적 속성
 인터페이스와 마찬가지로 클래스는 선언된 속성 뒤에 ? 를 추가해 속성을 옵션으로 선언합니다.
### 8.2.4 읽기 전용 속성
인터페이스와 마찬가지로 클래스도 선언된 속성 이름 앞에 readonly 키워드를 추가해 속성을 읽기전용으로 바꿉니다. readonly 키워드는 타입 시스템에만 존재하며 자바스크립트로 컴파일시 삭제됩니다.
# 8.3. 타입으로서의 클래스
타입 시스템에서의 클래스는 클래스 선언이 런타임 값과 타입 애너테이션에서 사용할수 있는 타입을 모두 생성해야한다는 점에서 상대적으로 독특합니다.
흥미롭게도 타입스크립트는 클래스의 동일한 멤버를 모두 포함하는 모든 객체 타입을 클래스에 할당할 수있다 간주합니다.
# 8.4. 클래스와 인터페이스
타입스크립트는 클래스 이름 뒤에 implements 키워드와 인터페이스 이름을 추가함으로써 클래스의 해당 인스턴스가 인터페이스를 준수한다고 선언 할 수 있습니다. 이렇게 하면 클래스를 각 인터페이스에 할당할수있어야 함을 나타냅니다. 타입 검사기에 의해 모든 불일치에 대해 타입오류가 발생합니다.
### 8.4.1 다중 인터페이스 구현
타입스크립트의 클래스는 다중인터페이스로 구현해 선언가능합니다. 두개의 충동하는 인터페이스를 구현하는 클래스를 선언하려고하면 클래스에 하나이상의 타입 오류가 발생합니다.
```javascript
   interface AgeisNumber(){
      age: Number;
   }
   interface AgsIsNotNumber(){
      age: () => string;
   }
   class AsNumber implements AgeisNumber, AgsIsNotNumber {
      age = 0;
   } //Error
```
동일한 클래스로 구현하지 않아야합니다.
# 8.5. 클래스 확장
 타입스크립트는 다른 클래스를 확장하거나 하위 클래스를 만드는 자바스크립트 개념에 타입검사를 추가합니다. 먼저 기본 클래스에 선언한 모든 메서드나 속성은 파생 클래스라도고 하는 하위 클래스에서 사용가능합니다.
```javascript
   class Teacher {
      teach(){
         console.log("The Sunset !!.");
      }
   }
   class StudentTeacher extends Teacher {
      learn(){
         console.log("I cannot afford the ~~.")
      }
   }
   const teacher = new StudentTeacher();

   teacher.teach();
   teacher.other();
   //Error
```
### 8.5.1 할당 가능성 확장
파생 인터페이스가 기본 인터페이스를 확장 하는 것과 마찬가지로 하위 클래스도 기본 클래스의 멤버를 상속합니다. 하위 클래스의 인스턴스는 기본 클래스의 모든 멤버를 가지므로 기본 클래스의 인스턴스가 필요한 모든곳에서 사용가늘합니다.

### 8.5.2 재정의된 생성자
하위클래스는 자체 생성자를 정의할 필요가 없습니다. 자체 생성자가 없눈 하위 클래스는 암묵적으로 기본 클래스의 생성자를 사용합니다. 자바스크립트 규칙에 따르면 하위클래스 생성자는 this 또는 super에 접근하기 전에 반드시 기본 클래스의 생성자를 호출해야합니다. 타입스크립트는 super()를 호출하기 전에 this 또는 super에 접근시 타입오류로 봅니다.

### 8.5.3 재정의된 메서드
하위클래스의 메서드가 기본 클래스의 메서드에 할당 될 수있는 한 하위클래스는 기본 클래스와 동일한 이름으로 새 메서드 선언이 가능합니다. 

### 8.5.4 재정의된 속성
하위클래스는 새타입을 기본 클래스의 타입에 할당할 수 있는 한 동일한 이름으로 기본 클래스의 속성을 명시적으로 다시 선언 가능합니다. 재정의된 메서드와 마찬가지로 하위 클래스는 기본 클래스와 구조적으로 일치해야합니다.
속성을 다시 선언하는 대부분의 하위클래스는 해당 속성을 유니언 타입의 더 구체적인 하위 집합으로 만들거나 기본 클래스 속성 타입에서 확장되는 타입으로 만듭니다.

# 8.6. 추상 클래스
때로는 일부 메서드의 구현을 선언 하지 않고 대신 하위 클래스가 해당 메서드를 제공할것을 예상하고 기본 클래스를 만드는 방법은 유용합니다. 추상화하려는 클래스 이름과 메서드앞에 abstract 키워드를 추가합니다.

# 8.7. 멤버 접근성
자바스크립트에서는 클래스 멤버 이름 앞에 #을 추가해 private 클래스 멤버임을 나타냅니다. 해당 클래스 인스턴스만 접근 가능합니다. 자바스크립트 런타임은 클래스 외부 코드 영역에서 private 메서드 속성 접근시 오류를 발생시킴으로 프라이버스를 강화합니다.

타입스크립트는 # 보다 먼저 만들어졌습니다. private 클래스 멤버 또한 지원하며 타입 시스템에서만 존재하는 메서드와 속성에 대해 좀더 미묘한 정의를 사용합니다.
* public
* protected
* private

### 8.7.1 정적 필드 제한자
static 키워드르 사용해 클래스 자체에서 멤버를 선언합니다. 타입스크립트는 static 키워드르 단독으로 사용하거나 readonly와 접근성 키워드르 함께 사용하도록 지원합니다. 함께 사용할경우 접근성 키워드를 작성하고 그 후 static, readonly 키워드가 옵니다.