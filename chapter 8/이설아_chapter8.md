# chapter 8. 클래스

## 클래스 메서드

- 독립함수를 이해하는 것과 동일한 방식으로 메서드를 이해함
- 매개변수 타입에 타입이나 기본값을 지정하지 않으면 any 타입을 기본으로 가짐
- 메서드를 호출하려면 허용 간으한 수의 인수가 필요
- 재귀함수가 아니라면 대부분 반환타입을 유추 가능

```tsx
class Meet {
  meet(name: string) {
    console.log("${name}, hi");
  }
}

new Meet.meet("jane");
```

- 클래스 생성자는 매개변수와 관련하여 전형적인 클래스 메서드처럼 취급
- 메서드 호출 시 올바른 타입의 인수가 올바른 수로 제공되는지 확인하기 위해 타입 검사를 수행

## 클래스 속성

- 클래스의 속성을 읽거나 쓰려면 클래스에 명시적으로 선언해야 함
- 클래스 속성은 인터페이스와 동일한 구문을 사용해 선언
- 클래스 속성 이름 뒤에는 선택적으로 타입 애너테이션이 붙음

```tsx
class FieldTrop {
  destination: string;

  constructor(destination: string) {
    this.destination = destination;
    console.log("목적지는 ${this.destination}");
  }
}
```

- 클래스 속성을 명시적으로 선언 시 클래스 인스터스에서 무엇이 허용되는지 빠르게 이해 가능

### 함수 속성

- 클래스 메서드와 독립함수의 동일한 구문을 사용해 매개변수와 반환 타입을 지정 가능
  ⇒ 함수 속성은 클래스 멤버로 할당된 값, 그 값은 함수임

### 초기화 검사

- 엄격한 컴파일러 설정이 활성화 된 상태에서는 undefined 타입으로 선언된 각 속성이 생성자에서 할당되었는지 확인
  → 클래스 속성에 값을 할당하지 않는 실수 에방 가능
- 엄격한 초기화 검사가 없다면 타입 시스템이 undefined 값에 접근 할 수 없다고 해도 클래스 인스턴스는 undefined 값에 접근 가능

> 확실하게 할당된 속성

- 클래스 생성자 다음에 클래스 속성을 의도적으로 할당하지 않는 경우가 있을 수 있음
- 초기화 검사를 적용하면 안되는 속성인 경우 이름 뒤에 !를 추가하여 검사를 비활성화 하도록 설정
- TS에 속성이 처음 사용되기 전에 undefined 값이 할당됨
  >

```tsx
class Activites {
  pending!: string[];

  initialize(pending: string[]) {
    this.pending = pending;
  }

  next() {
    return this.pending.pop();
  }
}

const active = new Activites();

active.initialize(["eat", "sleep"]);
active.next();
```

### 선택적 속성

- 선언된 속성 이름 뒤에 `?`를 추가해 속성을 옵션으로 선언
- 선택적 속성은 `| undefined`를 포함하는 유니언 타입과 거의 동일하게 작용
- 엄격한 초기화 검사는 생성자에게 선택적 속성을 명시적으로 설정하지 않아도 문제가 되지 않음

### 읽기 전용 속성

- 선언된 속성 이름 앞에 `readonly` 키워드를 추가해 속성을 읽기 전용으로 선언
- `readonly` 키워드는 타입 시스템에만 존재하며 JS로 컴파일 시 삭제 됨
- `readonly`로 선언된 속성은 선언된 위치 또는 생성자에게 초깃값만 할당할 수 잇음
  → 클래스 내의 매서드를 포함한 다른 모든 위치에서 속성을 읽을 수만 있고, 쓸 수는 없음
- 원시 타입의 초깃값을 갖는 `readonly`로 선언된 속성은 더 넓은 원싯값이 아니라 값의 타입이 가능한 좁혀진 리터럴 타입으로 유추됨

## 타입으로서의 클래스

- 클래스 선언이 런타임 값(클래스 자체)과 타입 애너테이션에서 사용할 수 있는 타입을 모두 생성함
- 클래스의 동일한 멤버를 모두 포함하는 모든 객체 타입을 클래스에 할당할 수 있는 것으로 간주
  → 구조적 타이핑이 선언되는 방식이 아니라 객체의 형태만 고려하기 때문

## 클래스와 인터페이스

- 클래스 이름 뒤에 `implements` 키워드와 인터페이스 이름을 추가함으로써 클래스의 해당 인터페이스에 할당할 수 있어야 함
  → 타입 검사기에 의해 모든 불일치에 대해서 타입 오류가 발생
- 인터페이스를 구현하는 것으로 클래스를 생성해도 클래스가 사용되는 방식은 변경되지 않음
  → 클래스가 이미 인터페이스와 일치하는 경우 TS의 타입 검사기는 인터페이스의 인스턴스가 필요한 곳에서 해당 인스턴스를 사용할 수 있도로 허용
- 인터페이스에서 클래스의 메서드 또는 속성 타입을 유추하지 않음
- 모든 인터페이스 멤버를 클래스 정의로 복사하지 않음
  → 인터페이스를 구현하면 클래스 인스턴스가 사용되는 곳에서 나중에 타입 검사기로 신호를 보내고 클래스 정의에서 표면적인 타입 오류가 발생

### 다중 인터페이스 구현

- 클래스에 구현된 인터페이스 목록은 인터페이스 일므 사이에 쉼표를 넣고, 개수 제한 없이 인터페이스를 사용 가능
- 두 인터페이스가 매우 다른 객체 형태를 표현하는 경우 동일한 클래스로 구현하지 않아야 함

## 클래스 확장

- 다른 클래스를 확장하거나 하위 클래스를 만드는 JS 개념에 타입 검사를 추가
- 기본 클래스에 선언된 모든 메서드나 속성은 파생 클래스라고도 하는 하위 클래스에서 사용 가능

### 할당 가능성 확장

- 파생 인터페이스가 기본 인터페이스를 확장하는 것과 마찬가지로 하위 클래스도 기본 플래스의 멤버를 상속
- 하위 클래스의 인스턴스는 기본 클래스의 모든 멤버를 가지므로 기본 클래스의 인스턴스가 필요한 모든 곳에서 사용 가능
  → 만약 기본 클래스에 하위 클래스가 가지고 있는 모든 멤버가 없으면 더 구체적인 하위 클래스가 필요할 때 사용할 수 없음
- 구조적 타입에 따라 하위 클래스의 모든 멤버가 동일한 타입의 기본 클래스에 이미 존재하는 경우 기본 클래스의 인스턴스를 하위 클래스 대신 사용 가능

### 재정의된 생성자

- 바닐라 JS와 마찬가지로 하위 클래스 자체 생성자를 정의할 필요가 없음
- 자체 생성자가 없는 하위 클래스는 암묵적으로 기본 클래스의 생성자를 사용함
- 타입 검사기는 기본 클래스 생성자를 호출할 때 올바른 매개변수를 사용하는지 확인
- super()를 호출하기 전에 this 또는 super에 접근하려고 하는 경우 타입 오류를 보고함

### 재정의된 메서드

- 하위 클래스의 메서드가 기본 클래스의 메서드에 할당될 수 있는 한 하위 클래스는 기본 클래스와 동일한 이름으로 새 메서드를 다시 선언 가능
- 기본 클래스를 사용하는 모든 곳에 하위 클래스를 사용할 수 있으므로 새 메서드에 타입도 기본 메서드 대신 사용할 수 있어야 함

### 재정의된 속성

- 새 타입을 기본 클래스에 타입에 할당할 수 있는 한 동일한 이름으로 기본 클래스의 속성을 명시적으로 다시 선언 가능
  → 하위 클래스는 기본 클래스와 구조적으로 일치해야 함
- 속성의 유니언 타입의 허용된 값 집합을 확장할 수는 없음
  → 만약 확장한다면 하위 클래스 속성은 더 이상 기본 클래스 속성 타입에 할당 불가

## 추상 클래스

- 추상화하려는 클래스 이름과 메서드 앞에 abstract 키워드를 추가함
- 추상화 기본 클래스에서 메서드의 본문을 제공하는 것을 건너뛰고, 인터페이스와 동일한 방식으로 선언됨

```tsx
abstract class School {
  readonly name: string;

  constructor(name: string) {
    this.name = name;
  }

  abstract getStudentTypes(): string[];
}

class Preschool extends School {
  getStudentTypes() {
    return ["preschooler"];
  }
}
```

- 추상클래스는 클래스의 세부 사항이 채워질거라 예상되는 프레임워크에서 자주 사용됨
  → 새 인스턴스 생성 시 하위 클래스를 사용해야 함

## 멤버 접근성

- TS에만 존재하는 클래스 메서드와 속성에 대해 조금 더 프라이버시 정의 집합 허용
  → JS로 컴파일 시 다른 모든 타입시스템 구문과 함께 제거
- 멤버 접근성은 클래스 멤버의 선언 이름 앞에 키워드 중 하나를 추가해 만듦
  - `public`(기본값): 모든 곳에서 누구나 접근 가능
  - `protected`: 클래스 내부 또는 하위 클래스에서만 접근 가능
  - `private`: 클래스 내부에서만 접근 가능
- `protected` 또는 `private`로 선언된 TS 클래스 멤버는 암묵적으로 `public`로 선언된 것처럼 동일한 JS 코드로 컴파일 됨
- 접근성 제한자는 `readonly`로 표시 가능
- `readonly`와 명시적 접근성 키워드로 멤버를 선언하려면 접근성 키워드를 먼저 적어야 함

<aside>
❗ TS의 이전 멤버 접근성 키워드를 JS의 `# private` 필드와 함께 사용 불가
`private` 필드는 기본적으로 항상 `private`이므로 `private` 키워드를 추가로 표시할 필요 없음

</aside>

### 정적 필드 제한자

- `static` 키워드를 단독으로 사용하거나 `readonly`와 접근성 키워드를 함께 사용할 수 있도록 지원
  →함께 사용할 경우 접근성 키워드를 먼저 작성 후, `static`, `readonly` 키워드를 가져옴
- `static` 클래스 필드에 대해 `readonly`와 접근성 제한자를 사용하면 해당 필드가 해당 클래스 외부에서 접근되거나 수정되는 것을 제한하는데 유용함
