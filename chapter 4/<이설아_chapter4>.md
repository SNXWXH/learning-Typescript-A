# chapter 4. 객체

## 객체 타입

- TS가 JS 코드를 이해하는 방법에 대한 핵심 개념이므로 객체 타입을 이해해야 함

### 객체 타입 선언

- 객체 리터럴과 유사해보이지만 필드 값을 대산 타입을 사용해 설명

```tsx
let letter: {
  abc: string;
  one: number;
};
```

### 별칭 객체 타입

- 각 객체 타입에 타입 별칭을 할당해 사용

```tsx
type st = {
  abc: string;
  one: number;
};

let letter: st;
```

## 구조적 타이핑

- TS의 타입 시스템은 구조적으로 타입화 되어있음
  → 타입을 충족하는 모든 값을 해당 타입의 값으로 사용할 가능
- 타입 검사기에서 정적 시스템이 타입을 검사하는 경우
- 덕 타이핑: 동적 타이핑의 한 종류로 객체의 변수 및 메서드의 집합이 객체의 타입을 결정하는 것
- JS → 덕 타이핑, TS → 구조적 타이핑

### 사용 검사

- 객체 타입으로 애너테이션된 위치에 값 제공 시 값을 해당 객체 타입에 할당할 수 있는지 확인
  → 할당하는 값에는 객체 타입의 필수 속성이 있어야 함

### 초과 속성 검사

- 변수가 객체 타입으로 선언되고, 초깃값에 객체 타입에서 정의된 것보다 많은 필드가 있으면 오류 발생
  → 변수를 객체 타입으로 선언하는 것은 타입 검사기가 해당 타입에 예상되는 필드에만 있는지 확인하는 방법
- 객체 타입으로 선언된 위치에서 생성되는 객체 리터럴에 대해서만 일어남
  → 기존 리터럴 제공 시 초과 속성 검사 우회

### 중첩된 객체 타입

- JS 객체는 다른 객체의 멤버로 중첩 가능 → TS의 객체 타입도 중첩된 객체 타입을 나타낼 수 있어야 함
- 객체 타입 설정하는 것과 동일하지만 기본 이름 대신 {…} 객체 타입을 사용

```tsx
type st = {
  letter: {
    abc: string;
    one: number;
  };
  tr: boolean;
};
```

### 선택적 속성

- 타입의 속성 애너테이션에서 `:` 앞에 `?` 추가
- 선택적으로 선언된 속성은 존재하지 않아도 됨

## 객체 타입 유니언

### 유추된 객체 타입 유니언

- 변수에 여러 객체 타입 중 하나가 될 수 있는 초깃값이 주어지면 해당 타입을 객체 타입 유니언으로 유추
- 객체 타입에 정의된 각각의 가능한 속성은 초깃값에 없는 타입이지만 각 객체 타입의 구성 요소로 주어짐

### 명시된 객체 타입 유니언

- 객체 타입의 조합을 명시하면 객체 타입을 더 명확히 정의 가능
- 코드를 더 작성해야 하지만 객체 타입을 더 많이 제어 할 수 있음
- 값의 타입이 객체 타입으로 구성된 유니언이라면 타입 시스템은 이런 모든 유니언 타입에 존재하는 속성에 대한 접근만 허용

### 객체 타입 내로잉

- 타입 검사기가 유니언 타입 값에 특정 속성이 포함된 경우에만 코드 영역을 실행한다는 것을 알게되면, 값의 타입을 해당 속성을 포함하는 구성 요소로 좁힘
  → 코드에서 객체의 형태를 확인하고 타입 내로잉이 객체에 적용

### 판별된 유니언

- JS와 TS에서 유니언 타입으로 된 객체의 또 다른 형태는 객체의 속성이 형태를 나타내도록 하는 것
- 판별값: 객체의 타입을 가르키는 속성
- 코드에서 판별 속성을 사용하여 타입 내로잉 수행

## 교차 타입

- JS 런타임 | 연산자가 & 연산자에 대응 → TS에서는 & 교차타입을 사용해 여러 타입을 동시에 나타냄
- 여러 기존 객체 타입을 별칭 객체 타입으로 결합해 새로운 타입을 생성
- 유니언 타입과 결합 가능 → 하나의 타입으로 판별된 유니언 타입을 설명하는데 유용

```tsx
type st = {
  abc: string;
  tr: boolean;
};

type letter = {
  abc: string;
  one: number;
};

type article = st & letter;
```

### 교차 타입의 위험성

- 컴파일러가 혼동하기 쉬움
- 교차 타입 사용 시 가능한 한 코드를 간결하게 유지
- 불가능한 타입을 생성 시킬 수도 있기에 두개의 타입을 함께 시도하면 never 타입이 됨
