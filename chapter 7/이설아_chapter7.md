# chapter 7. 인터페이스

- 연관된 일므으로 객체 형태를 설명하는 또 다른 방법
- 별칭으로 된 객체 타입과 여러 면에서 유사하지만 일반적으로 더 읽기 쉬운 오류 메시지, 더 빠른 컴파일러 성능, 클래스와의 더 나은 상호 운용성을 위해 선호 됨

## 타입 별칭 vs.인터페이스

```tsx
//타입 별칭
type v = {
	num = number;
	st = string;
}

//인터페이스
interface v{
	num = number;
	st = string;
}
```

- 인터페이스에 대한 TS의 할당 가능성 검사와 오류 메시지는 객체 타입에서 실행되는 것과 거의 동일
- 인터페이스와 타입 별칭 사이의 주요 차이점
  1. 인터페이스는 속성 증가를 위해 병합할 수 있음. 이 기능은 내장된 전역 인터페이스 또는 npm 패키지와 같은 외부 코드를 사용할 때 특히 유용
  2. 인터페이스는 클래스가 선언된 구조의 타입을 확인하는데 사용할 수 있지만 타입 별칭은 사용할 수 없음
  3. 일반적으로 인터페이스에서 TS 타입 검사기가 더 빨리 작동함. 인터페이스는 타입 별칭이 하는 것처럼 새로운 객체 리터럴의 동적인 복사 붙여넣기보다 내부적으로 더 쉽게 캐시할 수 있는 명명된 타입을 선언
  4. 인터페이스는 이름 없는 객체 리터럴의 별칭이 아닌 이름있는(명명된) 객체로 간주되므로 어려운 특이 케이스에서는 나타나는 오류 메시지를 좀 더 쉽게 읽을 수 있음
- 타입 별칭의 유니언 타입과 같은 기능이 필요할 때까지는 인터페이스를 사용하는 것이 좋음

## 속성 타입

- 인터페이스가 이상한 부분을 모델링할 수 있도록 유용한 타입 시스템 도구를 제공

### 선택적 속성

- 객체 타입과 마찬가지로 모든 객체가 필수적으로 인터페이스 속성을 가질 필요는 겂음
- 타입 애너테이션 `:` 앞에 `?` 를 사용하여 인터페이스의 속성이 선택적 속성임을 나타낼 수 있음
- 해당 인터페이스를 사용하는 객체에 필수 속성만 제공된다면 선택적 속성은 제공되거나 생략 가능
- undefined를 포함한 유니언 타입의 선택적 속성과 일반 속성 사이의 차이점과 관련된 주의 사항은 객체 타입뿐만 아니라 인터페이스에도 적용됨

```tsx
interface v{
	num = number;
	st = string;
}

const ok: v = {
	num = 152,
	st = "hi",
};

const missing: v = {
	num = 5
};
```

### 읽기 전용 속성

- 경우에 따라 인터페이스에 정의된 객체의 속성을 재할당하지 못하도록 인터페이스 사용자를 차단하고 싶음
  → 속성 이름 앞에 `readonly` 라는 키워드를 추가해 다른 값으로 설정될 수 없음을 나타냄
- `readonly` 속성은 평소대로 읽을 수 있지만 새로운 값으로 재할당 불가
- `readonly` 제한자는 타입 시스템에만 존재하며 인터페이스에서만 사용할 수 있음
- `readonly` 제한자는 객체의 인터페이스를 선언하는 위치에서만 사용되고 실제 객체에서는 적용되지 않음
- 가변 속성은 `readonly` 속성이 필요한 모든 위치에서 읽을 수 있음
- TS 타입 검사기를 사용해 개발 중에 그 속성이 수정되지 못하도록 보호하는 역할

### 함수와 메서드

- 인터페이스 멤버를 함수 타입으로 선언 가능
- 선언 방법 → JS에서 객체를 함수로 선언하는 방법과 동일
  1. 메서드 구문: 인터페이스 멤버를 `member(): void`와 같이 객체의 멤버로 호출되는 함수로 선언
  2. 속성 구문: 인터페이스 멤버를 `member: () => void` 와 같이 독립 함수로 동일하게 선언
- 메서드와 속성 선언은 대부분 서로 교환하여 사용 가능
- 메서드와 속성의 주요 차이점
  1. 메서드는 `readonly` 로 선언할 수 없지만 속성은 가능함
  2. 인터페이스 병합은 메서드와 속성을 다르게 처리함
  3. 타입에서 수행되는 일부 작업은 메서드와 속성을 다르게 처리함
- 현 시점에서 추천하는 스타일 가이드
  1. 기본 함수가 this를 참조할 수 있다는 것을 알고 있다면 메서드 함수를 사용. 가장 일반적으로 ㅋ르래스의 인스턴스에서 사용됨
  2. 반대의 경우는 속성 함수를 사용

### 호출 시그니처

- 값을 함수처럼 호출하는 방식에 대한 타입 시스템의 설명
  ⇒ 할당 가능한 매개변수와 반환 타입을 가진 함수
- 인터페이스와 객체 타입은 호출 시그니처로 선언 가능
- 함수 타입과 비슷하지만 콜론(`:`) 대신 화살표(`⇒`)로 표시
- 사용자 정의 속성을 추가로 갖는 함수를 설명하는데 사용 가능
- TS는 함수 선언에 추가된 속성을 해당 함수 선언의 타입에 추가하는 것으로 인식

### 인덱스 시그니처

- 일부 JS 프로젝트는 임의의 string 키에 값을 저장하기 위한 객체를 생성
  → ‘컨테이너’객체의 경우 모든 가능한 키에 대해 필드가 있는 인터페이스를 선언하는 것은 비현실적이거나 불가능
- TS는 인덱스 시그니처 구문을 제공하여 인터페이스의 객체가 임의의 키를 받고, 해당 키 아래의 특정 타입을 반환할 수 있음을 나타냄
- JS 객체 속성 조회(lookup)은 암묵적으로 키를 문자열로 변환하기 때문에 인터페이스의 객체는 문자열 키와 함께 일반적으로 사용됨
- 인덱스 시그니처는 일반 속성 정의와 유사하지만 키 다음에 타입이 있고 `{[i: string]: …}`과 같이 배열의 대괄호를 갖음
- 인덱스 시그니처는 객체에 값을 할당할 때 편리하지만 타입 안정성을 완벽하게 보장하지는 않음
- 객체가 어떤 속성에 접근하든 간에 값을 반환해야 함을 나타냄

> **속성과 인덱스 시그니처 혼합**

- 인터페이스는 명시적으로 명명된 속성과 포괄적인 용도의 string 인덱스 시그니처를 한번에 포함 가능
- 각각의 명명된 속성의 타입은 포괄적인 용도의인덱스 시그니처로 할당 가능해야 함
- 명명된 속성이 더 구체적인 타입을 제공하고, 다른 모든 속성은 인덱스 시그니처의 타입으로 대체하는 것으로 혼합해서 사용 가능
- 속성과 인덱스 시그니처를 혼합해서 사용하는 일반적인 타입 시스템 기법 중 하나는 인덱스 시그니처의 원시 속성보다 명명된 속성에 대해 더 구체적인 속성 타입 리터럴을 사용하는 것
- 명명된 속성의 ㅏ입이 인덱스 시그니처에 할당될 수 있는 경우 더 구체적인 속성 타입 리터럴을 사용하는 것을 허용
  >

> **숫자 인덱스 시그니처**

- 인덱스 시그니처는 키로 string 대신 number 타입을 사용할 수 있지만, 명명된 속성은 그 타입을 포괄적인 용도의 string 인덱스 시그니처의 타입으로 할당할 수 있어야 함
  >

### 중첩 인터페이스

- 객체 타입이 다른 객체 타입의 속성으로 중첩 가능한 것처럼 인터페이스 타입도 자체 인터페이스 타입 혹은 객체 타입을 속성으로 가질 수 있음

## 인터페이스 확장

- 인터페이스가 다른 인터페이스의 모든 멤버를 복사해서 선언할 수 있는 확장된 인터페이스 허용
- 확장할 인터페이스의 이름 뒤에 `extends` 키워드를 추가하여 다른 인터페이스를 확장한 인터페이스라는 것 표시
  → 파생 인터페이스를 준수하는 모든 객체가 기본 인터페이스의 모든 멤버도 가져야한다는 것을 TS에게 알려줌

```tsx
interface v{
	num = number;
}

interface value extends v{
	st = string;
}

let el: value = {
	num: 54,
	st = "hi",
};
```

- 인터페이스 확장은 프로젝트의 한 엔티티 타입이 다른 엔티티의 모든 멤버를 포함하는 상위 집합을 나타내는 실용적인 방법
  → 코드의 반복입력 작업 줄이기

### 재정의된 속성

- 파생 인터페이스는 다른 타입으로 속성을 다시 선언해 기본 인터페이스의 속성을 재정의하거나 대체 간으
- 타입 검사기는 재정의된 속성이 기본 속성에 할당되어 있도록 강요
  → 파생 인터페이스 타입의 인스턴스를 기본 인터페이스 타입에 할당 가능
- 속성을 재선언한느 대부분의 파생 인터페이스는 해당 속성을 유니언 타입의 더 구체적인 하위집합으로 만들거나 속성을 기본 인터페이스의 타입에서 확장된 타입으로 만들기 위해 사용

### 다중 인터페이스 확장

- 인터페이스는 여러 개의 다른 인터페이스 확장해서 선언
- 파생 인터페이스 이름에 있는 extends 키워드 뒤에 쉼표로 인터페이스 이름을 구분해 사용됨
- 파생 인터페이스는 모든 기본 인터페이스의 모든 멤버를 받음
- 여러 인터페이스를 확장하는 방식으로 인터페이스를 사용하면 코드의 중복을 줄이고 다른 코드 영역에서 객체의 형태를 더 쉽게 재사용 가능

## 인터페이스 병합

- 인터페이스의 중요한 특징 중 하나 → 서로 병합하는 능력
- 두 개의 인터페이스가 동일한 일므으로 동일한 스코프에 선언된 경우, 선언된 모든 필드를 포함하는 더 큰 인터페이스가 코드에 추가됨

```tsx
interface v{
	num = number;
}

interface  v{
	st = string;
}

//다음과 같음
interface v{
	num = number;
	st = string;
}
```

- 일반적인 TS에서는 인터페이스 병합을 자주 사용하지 않음
  → 인터페이스가 여러 곳에 선언되면 코드를 이해하기가 어려워지므로 가능하면 인터페이스 병합을 사용하지 않는 것이 좋음
- 외부 패키지 또는 Window 같은 내장된 전역 인터페이스를 보는데 유용함

### 이름이 충돌되는 멤버

- 병합된 인터페이스는 타입이 다른 동일한 이름의 속성을 여러번 선언 불가
- 속성이 이미 인터페이스에 선언되어 있다면 나중에 병합된 인터페이스에서도 동일한 타입을 사용해야 함
- 병합된 인터페이스는 동일한 이름과 다른 시그니처를 가진 메서드 정의 가능
