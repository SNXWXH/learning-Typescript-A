[Chapter7] 인터페이스
======================
인터페이스는 별칭으로 된 객체 타입과 유사하지만 읽기 쉬운 오류 메세지, 더 빠른 컴파일러 성능, 클래스와의 더 나은 상호 운용성을 선호합니다.
# 7.1. 타입 별칭 vs 인터페이스
```javascript
   type Poet = {
      born: number;
      name: string;
   }
```
```javascript
   interface Poet = {
      born: number;
      name: string;
   }
```
* 둘 사이의 차이점
   * 인턴페이스는 속성 증가를 위해 병합 가능합니다. 외부 코드를 사용할때 유용합니다.
   * 인터페이스는 클래스가 선언한 타입을 확인하는데 사용할 수 있지만, 타입 별칭은 사용불가합니다.
   * 일반적으로 인터페이스에서 타입검사기가 더 빨리 작용합니다.
   * 인터페이스는 이름 없는 객체 리터럴의 별칭이 아닌 이름 있는 객체로 간주됩니다.
# 7.2. 속성 타입
타입스크립트는 인터페이스가 이런 이상한 부분을 모델링 가능하도록 유용한 타입 시스템 도구를 제공합니다.
* 인터페이스와 타입 별칭은 매우 비슷하게 작동하므로 별칭 객체 타입에서도 사용 가능합니다.
### 7.2.1 선택적 속성
객체 타입과 마찬가지로 모든 객체가 필수적으로 인터페이스 속성을 가질 필요가 없습니다. 타입 애너테이션 : 앞에 ? 를 사용해 인터페이스의  속성이 선택적 속성임을 나타낼수있습니다.
### 7.2.2 읽기 전용 속성
경우에 따라 인터페이스에 정의된 객체의 속성을 재할당 하지 못하도록 인터페이스 사용자를 차단하고싶습니다. 속성 앞에 readonly 키워드를 추가해 다른 값은 설정될 수없음을 나타냅니다.
readonly는 인터페이스만 사용가능합니다.
### 7.2.3 함수와 메서드
 * 메서드 구문 : 인터페이스 멤버를 member() : void 와 같이 객체의 멤버로 호출하는 함수로 선언 
 * 속성 구문 : 인터페이스 멤버를 member:() => void 와 같이 독릭 함수와 동일하게 선언
```javascript
   interface HasBothFunctionTypes {
      property: () => string;
      method(): string;
   }
   const hasBoth: HasBothFunctionTypes = 
      property: ()=> "",
      method(){
         return "";
      }
   hasBoth.property();
   hasBoth.method();
```
### 7.2.4 호출 시그니처
인터페이스와 객체 타입은 호출 시그니처로 선언 가능합니다. 호출 시그니처는 값을 함수처럼 호출하는 방식에 대한 타입 시스템의 설명입니다.
함수와 호출 방식은 비슷하지만 : 대신 => 으로 표시합니다.

### 7.2.5 인덱스 시그니처
일부 자바스크립트 프로젝트는 임의의 string 키에 값을 저장하기 위한 객체를 생성합니다.
타입스크립트는 인덱스 시그니처 구문을 제공해 인터페이스의 객체가 임의의 키를 받고 해당 키 아래의 특정 타입을 반환할 수 있음을 나타냅니다.
   * 속성과 인덱스 시그니처 혼합
      * 인터페이스는 명시적으로 명명된 속성과 포괄적인 용도의 string 인덱스 시그니처를 한번에 포함 가능합니다. 명명된 속성이 더 구체적인 타입을 제공하고, 다른 모든 속성은 인덱스 시그니처의 타입으로 대체하는것으로 혼합해서 사용가능합니다.
   * 숫자 인덱스 시그니처
      * 타입스크립트 인덱스 시그니처는 키로 string 대신 number 타입을 사용가능하지만, 명명된 속성은 그 타입을 포괄적인 용도와 string 인덱스 시그니처의 타입으로 할당 가능해야합니다.

### 7.2.6 중첩 인터페이스
객체 타입이 다른 객체 타입의 속성으로 중첩 가능한 것처럼 인터페이스 타입도 자체 인터페이스 타입 혹은 객체 타입을 속성으로 가질 수 있습니다.

# 7.3. 인터페이스 확장
때론 서로 형태가 비슷한 여러개의 인터페이스를 가지게 됩니다. 타입스크립트는 인터페이스가 다른 인터페이스의 모든 멤버를 복사해서 선언 할 수 있는 확장된 인터페이스를 허용합니다. extends 키워드를 추가하여 사용합니다.

### 7.3.1 재정의된 속성
파생 인터페이스는 다른 타입으로 속성을 다시 선언해 재정의하거나 대체가능합니다. 타입검사기는 재정의된 속성이 기본 속성에 할당 되도록 강요합니다.

### 7.3.2 다중 인터페이스 확장
타입스크립트의 인터페이스는 여러개의 다른 인터페이스를 확장하여 선언가능합니다. extends 키워드 뒤에 인터페이스 이름을 구분해 사용하면 모든 멤버를 받습니다.
```javascript
   interface GivesBothAndEither extends GivesNumber, GivesString {
      giveEither(): string;
   }
```
# 7.4. 인터페이스 병합
인터페이스의 중요한 특징 중 하나는 서로 병합하는것입니다.
동일한 스코프에서 선언된 경우, 선언된 모든 필드를 포함하는 더 큰 인터페이스가 코드에 추가됩니다.
```javascript
   interface Merged(){
      fromFirst: string;
   }
   interface Merged(){
      fromSecond: number;
   }
```
일반적으로 개발할때는 인터페이스 병합을 자주 사용하지 않습니다. 여러 곳에 선언되면 코드를 이해해지기 어려워지므로 가능하면 사용하지 않는것이 좋습니다.

### 7.4.1 이름이 충돌되는 멤버
병합된 인터페이스는 타입이 다른 동일한 이름의 속성을 여러번 선언 가능합니다. 그러나 동일한 이름과 다른 시그니처를 가진 메서드는 정의 할 수 있습니다. 함수 오버로드가 발생합니다.
