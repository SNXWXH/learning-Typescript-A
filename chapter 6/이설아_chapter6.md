# chapter 6. 배열

# JS에서의 배열

- 유연하고, 내부에 모든 타입의 값을 혼합해서 저장할 수 있음

```tsx
const el = [true, null, "hi", 45];

el.push("hello", [23]);

console.log(el);

//[true, null, "hi", 45, "hello", [23]]
```

## 문제점

- 배열은 하나의 특정 타입 값만 가짐
- 다른 타입의 값을 추가하게 되면 배열을 읽을 때 혼란을 줌
- 최악의 상황으로는 프로그램에 문제가 될 만한 오류가 발생할 수도 있음

# TS에서의 배열

- 초기 배열에 어떤 데이터 타입이 있는지 기억하고, 배열이 해당 데이터 타입에서만 작동하도록 제한
  ⇒ 배열의 데이터 타입을 하나로 유지
  ```tsx
  //string 타입
  const st = ["hi", "hello"];

  //string 타입 추가
  el.push("welcome");

  //boolean 타입 추가
  //오류
  el.push(ture);
  ```

## 배열 타입

- 변수 초기값이 필요하지 않음
  → undefined로 시작해서 나중에 배열 값을 받을 수 있음
- 타입 애너테이션을 통해 배열이 포함해야 하는 값의 타입을 지정해줘야 함
  ```tsx
  let num: number[];
  num = [1, 2, 3];
  ```

### 배열과 함수 타입

```tsx
//string 타입의 배열을 반환하는 함수
let el: () => string[];

//각각의 string 타입을 반환하는 함수 배열
let st: (() => string)[];
```

### 유니언 타입 배열

- 유니언 타입 배열에서 괄호 사용은 중요

```tsx
//string 또는 number 타입의 배열
let stNum: string | number[];

//각각 string 또는 number 타입인 요소의 배열
let arStNum: (string | number)[];
```

- 배열의 선언에서 두 가지 이상의 요소 타입이 포함되는 경우 유니언 타입 배열임을 알게 됨
  ⇒ 배열의 요소 타입은 배열에 담긴 요소에 대한 모든 가능한 타입의 집합
  ```tsx
  //타입: (string | num)[]
  const stNum = ["hi", "hello", 42];
  ```

### any 배열

- 초기에 빈 배열로 설정된 변수에서 타입 애너테이션을 포함하지 않으면 TS는 배열을 any[]로 취급하고 모든 요소를 받을 수 있음
- 타입 애너테이션이 없는 빈 배열은 잠재적으로 잘못된 값을 허용해 TS의 타입 검사기가 갖는 이점을 부분적으로 무력화 시킬 수 있음

```tsx
//타입: any[]
let v = [];

//타입: string[]
v.push("");

//타입: (number | string)[]
v[0] = 0;
```

### 다차원배열

```tsx
//2차원 배열
let arr: number[][];

let arr = [
  [1, 2, 3],
  [4, 5, 6],
];

//number[][]타입
let numarr: num[][];
```

## 배열의 멤버

- TS는 배열의 멤버를 찾아서 해당 배열의 타입 요소를 되돌려주는 전형적인 인덱스 기반 접근 방식을 이해함

```tsx
const st = ["hi", "hello"];

//string 타입
cosnt string = st[0];

const stNum = ["hi", 42];

//string | number 타입
const stNumber = stNum[0];
```

### 주의 사항

- 대부분의 올바른 타입을 얻을 수 있지만, 때로는 값 타입에 대한 타입시스템이 이해가 올바르지 않을 수도 있음
- TS는 모든 배열의 요소에 대해 접근이 해당 배열의 요소를 반환한다고 가정하지만, JS에서조차도 배열의 길이보다 큰 인덱스로 배열 요소에 접근하면 undefined 제공

## 스프레드와 나머지 매개변수

### 스프레드

- `…` 스프레드 연산자를 사용해 배열을 결합
  → 입력된 배열 중 하나의 값이 결과 배열에 포함될 것임을 이해
- 만약 입력된 배열이 동일한 타입이라면 출력 배열도 동일한 타입
- 서로 다른 타입의 두 배열을 함께 스프레드해 새 배열을 생성하면 새 배열은 두 개의 원래 타입 중 유니언 타입 배열로 이해

```tsx
//string[] 타입
const st = ["hi", "hello"];

//number[] 타입
const num = [45, 68, 352];

//(string | number)[] 타입
const join = [...st, ...num];
```

### 나머지 매개변수 스프레드

- 나머지 매개변수로 배열을 스프레드하는 JS 실행을 인식하고 이에 타입 검사 수행
- 나머지 매개변수를 위한 인수로 사용되는 배열은 나머지 매개변수와 동일한 타입을 가져야 함

## 튜플

- 이론상 어떤 크기도 될 수 있으나, 튜플을 사용하는 것이 좋음
- 튜플:고정된 크기의 배열
- 튜플 배열

  - 각 인덱스에 알려진 특정 타입을 가지며 배열의 모든 간으한 멤버를 갖는 유니언 타입보다 더 구체적
  - 튜플 타입을 선언하는 구문은 배열 리터럴 처럼 보이지만 요소의 값 대신 타입을 적음

- JS에서는 단일 조건을 기반으로 두개의 변수에 초깃값을 서청하는 것처럼 한번에 여러 값을 할당하기 위해 튜플과 배열 구조 분해 할당을 자주 사용

### 튜플 할당 가능성

- 튜플 타입은 가변 길이의 배열 타입보다 더 구체적으로 처리됨
  ⇒ 가변 길이의 배열 타입은 튜플 타입에 할당할 수 없음

### 나머지 매개변수로서의 튜플

- 튜플은 구체적인 길이와 요소 타입 정보를 가지는 배열로 간주되므로 함수에 전달할 인수를 저장하는데 특히 유용
- `…` 나머지 매개변수로 전달된 튜플에 정확한 타입 검사를 제공할 수 있음
- 나머지 매개변수 튜플을 사용하고 싶다면 여러 번 함수를 호출하는 인수 목록을 배열에 저장해 함께 사용 가능

### 튜플추론

- 생성된 배열을 튜플이 아닌 가변 길이의 배열로 취급
- 배열이 변수의 초깃값 또는 함수에 대한 반환값으로 사용되는 경우, 고정된 크기의 튜플이 아니라 유연한 크기의 배열로 가정
- TS에서는 값이 일반적인 배열 타입 대신 좀 더 구체적인 튜플 타입이어야 함을 두 가지 방법으로 나타냄
  1. 명시적 튜플 타입
     - 함수에 대한 반환 타입 애너테이션처럼 튜플 타입도 타입 애너테이션에 사용 가능
     - 함수가 튜플 타입을 반환한다고 선언되고, 배열 리터럴을 반환한다면 해당 배열 리터럴은 일반적인 가변 길이의 배열 대신 튜플로 간주됨
  2. const 어서션
     - 명시적 타입 애너테이션에 튜플 타입을 입력하는 작업은 코드 변경에 따라 작성 및 수정이 필요한 구문을 추가해야 함
       → 이를 해결하기 위해 값 뒤에 넣을 수 있는 const 어셔션인 as const 연산자를 제공
     - TS에 배치되면 배열이 튜플로 처리되어야 함을 나타냄
     - 유연한 크기의 배열을 고정된 크기의 튜플로 전환하는 것을 넘어서 해당 튜플이 읽기 전용이고 값 수정이 예상되는 곳에서 사용할 수 없음을 나타냄
     - 튜플을 반환하는 함수로부터 반환된 값은 보통 즉시 구조화되지 않으므로 읽기 전용 튜플은 함수를 사용하는데 방해가 되지 않음
