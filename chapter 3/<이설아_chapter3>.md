# chapter 3. 유니언과 리터럴

## 유니언 타입

- 유니언: 값에 허용된 타입을 두 개 이상의 가능한 타입으로 확장하는 것
- TS는 가능한 값 혹은 구성 요소 사이에 `|` 연산자를 사용해 유니언 타입을 나타냄

### 타입 선언

- 타입 애너테이션으로 타입을 정의하는 모든 곳에서 사용 가능

### 속성

- 값이 유니언 타입일 때 유니언으로 선언한 모든 가능한 타입에 존재하는 멤버 속성에만 접근 가능(안전조치)
- 이 외의 타입에 접근 시 타입 검사 오류 발생

## 내로잉

- 값이 정의, 선언 혹은 이전에 유추된 것보다 더 구체적인 타입임을 코드에서 유추하는 것
- 타입 가드
  - 타입을 좁히는데 사용할 수 있는 논리적 검사
  - 값을 할당한 내로잉, 조건 검사를 통한 내로잉, typeof 검사를 통한 내로잉

### 값을 할당한 내로잉

- 변수에 유니언 타입 애너테이션이 명시되고 초기값이 주어질 때 값 할당 내로잉이 작동
- 변수가 나중에 유니언 타입 중 하나로 값을 받을 수 있지만 처음에는 초기에 할당된 값의 타입으로 시작한다는 것을 이해

```tsx
let st: number | string; //유니언 타입 에너테이션
st = "Hi"; //string타입으로 선언
st.toUpperCase();
```

### 조건 검사를 통한 내로잉

- if문 내에서 변수가 알려진 값과 동일한 타입인지 확인
- TS 타입 검사 로직은 JS 코딩 패턴을 미러링하여 구현

### typeof 검사를 통한 내로잉

- typeof 연산자를 통아혀 해당 변수의 타입을 확인

## 리터럴 타입

- 원시 타입 값 중 어떤 것이 아닌 특정 원싯값으로 알려진 타입
- 원시 타입은 존재할 수 있는 모든 가능한 문자열의 집합을 나타내지만, 리터럴 타입은 하나의 문자열만 나타냄

```tsx
//const ts : "typescript"
const ts = "typescript";
```

- 각 원시 타입은 해당 타입이 가질 수 있는 가능한 모든 리터럴 값의 전체 조합
  → 원시 타입은 해당 타입의 가능한 모든 리터럴 값의 집합

### 리터럴 할당 가능성

- 동일한 원시 타입이라도 서로 다른 리터럴 타입은 서로 할당할 수 없음

```tsx
let abc: "alp";
abc = "alp";

//abc는 alp로 리터럴 타입을 지정했기에 "num"값으로 할당 불가
abc = "num";
```

## null에 대한 엄격한 확인

- null에 대한 엄격한 확인이 활성화 되면 코드가 null 혹은 undefined값으로 인한 오류로부터 안전 여부를 쉽게 파악할 수 있음
  → 충돌 방지

### 초기값이 없는 변수

- JS에서 초기값이 없는 변수는 기본적으로 undefined
- 변수 타입에 undefined가 포함되어 있으면 오류가 보고 되지 않음

## 타입 별칭

- 재사용하는 타입에 변수 할당
- TS에만 존재
- 다른 별칭 참조 가능
