[Chapter3] 유니언과 리터럴
======================

# 1. 유니언 타입
* 유니언 : 값에 허용된 타입을 두개 이상의 가능한 타입으로 확장하는것 (이거 혹은 저거)
* 내로잉 ; 값에 허용된 타입이 하나 이상의 가능한 타입이 되지 않도록 하는것
## 3.1. 유니언 타입
* mathematician : undefined 이거나 string
* 타입 스크립트는 가능한 값 또는 구성 요소 사이에 | 연산자를 사용해 유니언 타입을 나타냄
  * string | undefined 타입으로 간주
### 3.1.1. 유니언 타입 선언
변수의 초깃 값이 있더라도 변수에 대한 명시적 타입 애너테이션을 제공하는 것이 유용할 때 유니언 타입을 사용합니다. 유니언 타입 선언은 타입 애너테이션으로 타입을 정의하는 모든 거세서 사용할 수 있습니다.
### 3.1.2 유니언 속성
값이 유니언 타입 일때 유니언으로 선언한 모든 가능한 타입에 존재하는 멤버 속성에만 접근 할 수 있습니다.
모든 유니언 타입에 존재하지 않는 속성에 대한 접근을 제한하는 것은 안전 조치에 해당합니다.
유니언 타입으로 정의된 타입 중 하나의 타입으로 된 값의 속성을 사용하려면 코드에서 구체적인 타입 중 하나라는것을 타입스크립트에 알리는것을 '내로잉' 이라고 합니다.
****
## 3.2 내로잉
내로잉은 값이 정의, 선언 혹은 이전에 유추된 것 보다 더 구체적인 타입임을 코드에서 유추하는 것 입니다. 타입스크립트가 값의 타입이 이전에 알려진것보다 더 좁혀졌다는 것을 알게되면 값을 더 구체적인 타입으로 취급합니다.
* 타입 가드 : 타입을 좁히는 데 사용할 수 있는 논리적 검사 
### 3.2.1. 값 할당을 통한 내로잉
변수에 값을 직접 할당하면 타입스크립트는 변수의 타입을 할당된 값의 타입으로 좁힙니다. 변수에 유니언 타입 애너테이션이 명시되고 초깃값이 주어질 때 값 할당 내로잉이 작동합니다.
타입스크립트는 변수가 나중에 유니언 타입으로 선언된 타입 중 하나의 값을 받을 수 있지만, 초기에 할당된 값의 타입으로 시작합니다.
```javascript
   let inventor : number | string = "Hedy Lamarr";
   inventor.toUpperCase();
   inventor.toFixed();
   //Error : Property 'toFixed' does not exist on type 'string';
``` 
### 3.2.2 조건 검사를 통한 내로잉
타입스크립트에서는 변수가 알려진 값과 같은지 확인하는 if 문 을 통해 변수의 값을 좁히는 방법을 선택합니다. 조건부 로직으로 내로잉할때, 타입스크립트 타입 검사 로직은 훌륭한 자바스크립트 코딩 패턴을 미러링해 구현합니다. 
### 3.2.3 typeof 검사를 통해 내로잉
타입스크립트는 직접 값을 확인해 typeof 연산자를 사용할 수 있습니다.
```javascript
  let researcher = Math.random() > 0.5
  ? "RR"
  :51;
  if (typeof resarcher = "string"){
    researcher.toUpperCase();
  }
``` 
****
## 3.3 리터럴 타입
두 개 이상의 잠재적 타입이 될 수 있는 값을 위해 유니언 타입과 내로잉을 살펴보았으니 지급부터는 리터럴 타입을 소개하겠습니다. 원시 타입 값 중 어떤 것이 아닌 '특정 원싯값'으로 알려진 리터럴 타입 개념입니다. 

각 원시 타입은 해당 타입이 가질 수 있는 가능한 모든 리터럴 값의 전체 조합으로 생각 할 수 있습니다.
* boolean: true | false
* null 과 undefined 0 | 1 | 2 |
* number
* string
유니언 타입 애너테이션으로는 리터럴과 원시 타입을 섞어서 사용할 수있습니다.

### 3.3.1 리터럴 할당 가능성
앞서 number 와 string 과 같은 서로 다른 원시 타입이 서로 할당되지 못한다는 것을 보았습니다. 마찬가지로 0과 1처럼 동일한 원시타입일지라도 서로 다른 리터럴 타입은 서로 할당 할수 없습니다.

## 3.4 엄격한 null 검사
엄격한 null 검사란 타입 시스템 영역인 '잠재적으로 정의되지 않은 undefined 값' 으로 작업할때 특히 두드러집니다. 

### 3.4.1 십억 달러의 실수
십억 달러의 실수는 다른 타입이 필요한 위치에서 null 값을 사용하도록 허용하는 많은 타입 시스템을 가르키는 업계 용어입니다. 타입스크립트 컴파일러는 가장 유용한 옵션인 strictNullChecks 는 엄격한 null 검사를 활성화 할지 여부를 정합니다.

### 3.4.2 참 검사를 통한 내로잉
타입스크립트에서는 truthy로 확인된 일부에 한해서만 변수의 타입을 좁힐 수 있습니다.
논리 연산자인 &&와 ? 는 참여부를 검사합니다. 
```javascript
  let biologist = Math.random() > 0.5 && "RR";

  if(biologist){
    biologist; // 타입 : String
  } 
  else {
    biologist; // 타입 false | string
  }
  
``` 

### 3.4.3 초깃값이 없는 변수
자바스크립트는 초깃갑이 없는 변수는 기본적으로 undefined 됩니다. 만약 undefined를 포함하지않는 타입으로 변수를 선언 후, 값을 할당되기전 오류가 납니다.

## 3.5 타입 별칭
코드에서 볼 수 있는 유니언 타입 대부분은 두세개의 구성요소를 갖습니다. 가끔 긴 유니언 타입을 발견할 수 있는데, 이때 재사용하는 타입에 더 쉬운이름을 할당하는 '타입 별칭'이 있습니다.
```javascript
  type 새로운 이름 = 타입
  type RawData = boolean | number | string | null | undefined;
``` 
### 3.5.1 타입 별칭은 자바스크립트가 아니다
타입 별칭은 자바스크립트로 컴파일 되지 않습니다. 타입 별칭은 순전히 타입시스템에만 존재하므로 런타임 코드에서 참조 불가합니다.
### 3.5.2 타입 별칭 결합
타입 별칭은 다른 타입 별칭을 참조 가능합니다. 유니언 타입인 타입 별칭을 포함하고 있다면 다른 타입 별칭을 참고하는것이 유용합니다.
****
